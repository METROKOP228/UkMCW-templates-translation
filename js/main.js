const replacements_id = {
    "=y\n": "=т\n",
    "ID table": "ID таблиця",
    "editions": "видання",
    "{{edition|": "{{el|",
    "firstcolumnname": "назвапершогостовпця",
    "nonameid": "немаєназвиid",
    "notnamespaced": "безінтервалуміжіменами",
    "shownumericids": "показатичисловийid",
    "showaliasids": "показатипсевдонімиid",
    "showfluidtags": "показатитеґирідини",
    "showblocktags": "показатитеґиблока",
    "edition": "видання",
    "showitemtags": "показатитеґипредмета",
    "showentitytags": "показатитеґисутности",
    "showforms": "показатиформи",
    "notshowbeitemforms": "непоказуватиформипредмету",
    "itemform": "формапредмету",
    "itemform2": "формапредмету2",
    "generatetranslationkeys": "генеруватиключіперекладу",
    "nocat": "некат",
    "displayname": "відображуванеім'я",
    "spritename": "назваспрайту",
    "nameid": "назваid",
    "aliasid": "псевдонімиid",
    "fluidtags": "теґирідини",
    "blocktags": "теґиблока",
    "itemtags": "теґипредмета",
    "entitytags": "теґисутности",
    "translationkey": "ключперекладу",
    "translationtype": "типперекладу",
    "foot=": "підвал=",
    "foot =": "підвал =",
    "spritetype=block": "типспрайту=блок",
    "spritetype=item": "типспрайту=предмет",
    "spritetype=entity": "типспрайту=сутність",
    "spritetype=biome": "типспрайту=біом",
    "spritetype=environment": "типспрайту=оточення",
    "spritetype=env": "типспрайту=оточення",
    "spritetype=effect": "типспрайту=ефект",
    "form=block": "форма=блок",
    "form=item": "форма=предмет",
    "form=entity": "форма=сутність",
    "form=biome": "форма=біом",
    "form=environment": "форма=оточення",
    "form=effect": "форма=ефект",
    "form": "форма",
    "Block entity": "Блок-сутність",
    "No displayed name": "Немає відображуваного імені"
};
const replacements_sound = {
    "SoundLine": "ЗвуковийРядок",
    "SoundTable": "ЗвуковаТаблиця",
    "Sound table": "Звукова таблиця",
    "sound": "звук",
    "sound1": "звук1",
    "sound2": "звук2",
    "sound3": "звук3",
    "sound4": "звук4",
    "sound5": "звук5",
    "sound6": "звук6",
    "sound7": "звук7",
    "sound8": "звук8",
    "subtitle=": "субтитри=",
    "source=block": "джерело=блок",
    "description": "опис",
    "translationkeynote": "ключперекладунотатка",
    "translationkey": "ключперекладу",
    "pitch": "висотазвуку",
    "distance": "відстань",
    "rowspan": "рядки",
    "volume": "гучність",
    "foot=": "підвал=",
    "nocat": "некат",
    "type": "тип",
    "Baby:": "Дитинча:",
    "=''varies''": "=''варіюється''",
    "=master": "=загальне",
    "=music": "=музика",
    "=record": "=платівка",
    "=weather": "=погода",
    "=hostile": "=ворожі",
    "=neutral": "=нейтральні",
    "=player": "=гравець",
    "overridesource": "перевизначитиджерело",
    "source": "джерело",
    "=ambient": "=середовище",
    "voice": "голос",
    "dependent": "залежний",
    "''None''": "''Немає''",
    "templatepage": "сторінкашаблону",
    "idnote": "idнотатка",
    "Unused sound event": "Невикористана звукова подія",
    "Once the block has broken": "Коли блок зламано",
    "When the block is placed": "Коли блок розміщено",
    "While the block is in the process of being broken": "Поки блок знаходиться в процесі руйнування",
    "Falling on the block with fall damage": "Падіння на блок з отриманням шкоди",
    "Walking on the block": "Ходіння по блоку",
    "Jumping from the block": "Стрибання з блока",
    "Falling on the block without fall damage": "Падіння на блок без отримання шкоди"
};
const replacements_vn = {
    "Version nav": "Версія навігація",
    "version nav": "Версія навігація",
    "Infobox version": "Версія навігація",
    "infobox version": "Версія навігація",
    "othereditions": "іншівидання",
    "edition": "видання",
    "title": "назва",
    "|server": "|сервер",
    "| server": "| сервер",
    "prefix": "префікс",
    "image": "зобр",
    "name": "ім'я",
    "|client": "|клієнт",
    "| client": "| клієнт",
    "build": "збірка",
    "internal": "внутрішній",
    "versioncode": "кодверсії",
    "prevparent": "поперверсія",
    "|prev": "|попер",
    "| prev": "| попер",
    "nextparent": "настверсія",
    "next": "наст",
    "type": "тип",
    "unreleased": "невипущено",
    "planned": "заплановано",
    "|date": "|дата",
    "| date": "| дата",
    "compiled": "скомпільований",
    "devversions": "поперзбірки",
    "version": "версія",
    "hash": "хеш",
    "downloads": "завантаження",
    "file": "файл",
    "other": "інше",
    "maps": "карти",
    "map": "карта",
    "protocol_manual": "протокол_вручну",
    "data_manual": "дані_вручну",
    "no_protocol": "немає_протоколу",
    "no_data": "немає_даних",
    "no_": "немає_",
    "_manual": "_вручну",
    "parent": "знімокдля",
    "{{vl": "{{вер",
    "dl=": "зп=",
    "dl =": "зп =",
    "Client": "Клієнт",
    "Server": "Сервер",
    "editorver": "editorвер",
    "No corresponding server": "Немає відповідного сервера",
    "vernum": "версія"
};
const replacements_entity = {
    "health": "здоров'я",
    "armor": "обладунки",
    "behavior": "поведінка",
    "classification": "класифікація",
    "family": "сімейство",
    "damage": "атака",
    "size": "розмір",
    "group": "група",
    "speed": "швидкість",
    "knockbackresistance": "стійкістьдовіддачі",
    "spawn": "спавн",
    "equipment": "екіпірування",
    "usableitems": "корисніпредмети",
    "rarity": "рідкісність",
    "notes": "примітки",
    "invimage": "інвзображення",
    "image": "зобр",
    "{{Infobox entity": "{{Сутність",
    "{{Entity": "{{Сутність",
    "{{hp": "{{оз",
    "{{drop": "{{дроп",
    "caption": "підпис"
};
const replacements_block = {
    "Infobox block": "Блок",
    "rarity": "рідкісність",
    "renewable": "поновл",
    "stackable": "склад",
    "tool": "інструмент",
    "title": "назва",
    "hardness": "міцн",
    "durability": "стійкість",
    "light": "світ",
    "transparent": "прозор",
    "waterloggable": "затопл",
    "heals": "відн",
    "flammable": "займист",
    "lavasusceptible": "загорвлави",
    "=No": "=Ні",
    "= No": "= Ні",
    "=Yes": "=Так",
    "= Yes": "= Так",
    "invimage": "інвзображення",
    "image": "зобр",
    "group": "група",
    "caption": "підпис",
    "extratext": "додатковийтекст",
    "tntres": "вибухост"
};
const replacements_drops = {
    "DropsTableHead": "Голова таблиці дропу",
    "DropsLine": "Рядок дропу",
    "DropsTableFoot": "Підвал таблиці дропу",
    "version": "версія",
    "image": "зобр",
    "namelink": "посиланняназви",
    "namenote": "нотатканазви",
    "name": "назва",
    "rollchancenote": "нотаткашансунауспіх",
    "rollchance": "шанснауспіх",
    "lootingquantity": "кількістьзграбунком",
    "quantitylimit": "обмежкількости",
    "dropchance": "шансдропу",
    "lootingchance": "шансзграбунком",
    "playerkill": "вбивствогравця",
    "=yes": "=так",
    "=no": "=ні",
    "quantity": "кількість"
};
const replacements_history = {
    "HistoryTable": "ТаблицяІсторії",
    "HistoryLine": "РядокІсторії",
    "|dev": "|збірка",
    "|slink": "|поперпосилання",
    "|link": "|посилання",
    "|experiment": "|експеримент",
    "|exp": "|експ",
    "[[File:": "[[Файл:",
    "1.13/Flattening": "1.13 (Java Edition)/Flattening"
};
const replacements_looming = {
    "{{Looming": "{{Ткацтво",
    "{{looming": "{{ткацтво",
    "|head": "|голова",
    "| head": "| голова",
    "|foot": "|підвал",
    "| foot": "| підвал",
    "name": "назва",
    "Blink": "СтягПосилання",
    "Olink": "ВихідПосилання",
    "showdescription": "показатиопис",
    "description": "опис",
    "ingredients": "інгредієнти"
};
const replacements_biome = {
    "{{Infobox biome": "{{Біом",
    "title": "назва",
    "imagesize": "зобр1розмір",
    "image": "зобр",
    "group": "група",
    "caption": "підпис",
    "extratext": "додатковийтекст",
    "data": "дані",
    "structures": "структури",
    "features": "особливості",
    "blocks": "блоки",
    "temperature": "температура",
    "downfall": "падіння",
    "precipitation": "опади",
    "snow_accumulation": "накопичення_снігу",
    "skycolor": "колірнеба",
    "fogcolor": "коліртуману",
    "grasscolor": "коліртрави",
    "foliagecolor": "колірлистя",
    "watercolor": "колірводи",
    "underwaterfogcolor": "колірпідводноготуману",
    "EnvLink": "Посилання/Оточення",
    "BlockLink": "Посилання/Блок",
    "Yes": "Так",
    "No": "Ні",
    "{{only": "{{тільки",
    "{{color": "{{колір",
    "short=y": "короткий=т",
    "short=1": "короткий=1"
};
const replacements_spawn = {
    "Spawn attempt succeeds only in slime chunks.": "Спроба заспавнитися вдається лише в слимакових чанках.",
    "{{Spawn table": "{{Таблиця появи",
    "{{Spawn row": "{{Ряд появи",
    "title": "назва",
    "image": "зобр",
    "group": "група",
    "caption": "підпис",
    "edition": "видання",
    "creature": "істота",
    "monster": "монстр",
    "ambient": "оточення",
    "watercreature": "водянаістота",
    "waterambient": "воднеоточення",
    "underground": "підземний",
    "name": "ім'я",
    "weight": "вага",
    "size": "розмір",
    "charge": "заряд",
    "budget": "витрати",
    "note": "примітка",
    "notename": "назвапримітки"
};

const replacements_item = {
    "{{Infobox item": "{{Предмет",
    "title": "назва",
    "imagesize": "зобр1розмір",
    "invimage": "інвзображення",
    "image": "зобр",
    "group": "група",
    "caption": "підпис",
    "extratext": "додатковийтекст",
    "rarity": "рідкісність",
    "durability": "міцн",
    "armor": "захист",
    "renewable": "поновл",
    "stackable": "склад",
    "heals": "відновлює",
    "effects": "ефекти",
    "Yes": "Так",
    "No": "Ні",
    "hunger": "голод",
    "Renewable resource#Vault|except via ominous vault": "Поновлювані ресурси#Сховище|хіба що через зловісне сховище",
    "Common": "Звичайний",
    "Uncommon": "Незвичайний",
    "Rare": "Рідкісний",
    "Epic": "Епічний",
    "only": "тільки",
    "short": "короткий",
    "upcoming": "заплановане",
    "until": "доки",
    "+1 in": "+1 у"
};

const replacements_itemEntity = {
    "rarity": "рідкісність",
    "durability": "міцн",
    "renewable": "поновл",
    "stackable": "склад",
    "flammable": "займист",
    "size": "розмір",
    "networkid": "мережевийid",
    "drops": "дроп",
    "health": "здоров'я",
    "type": "тип",
    "Common": "Звичайний",
    "Uncommon": "Незвичайний",
    "Rare": "Рідкісний",
    "Epic": "Епічний",
};
    
const monthes = {
    "January": "січня",
    "February": "лютого",
    "March": "березня",
    "April": "квітня",
    "May": "травня",
    "June": "червня",
    "July": "липня",
    "August": "серпня",
    "September": "вересня",
    "October": "жовтня",
    "November": "листопада",
    "December": "грудня"
};

CodeMirror.defineSimpleMode("customMode", {
    start: [
        { regex: /\<\-\-.*?\-\-\>/, token: "custom-comment" },             // Comments ( <-- something --> )
        // { regex: /\{\{\#.*?\}\}/, token: "custom-parser" },             // Parser functions ( {{#something}} )
        { regex: /==.*==/, token: "custom-heading" },                      // Headings ( == something == )
        { regex: /\{\{\{.*?\}\}\}/, token: "custom-parameter" },           // Parameters ( {{{something}}} )
        { regex: /\{\{/, token: "custom-template", next: "template" },     // Templates ( {{ )
        { regex: /\}\}/, token: "custom-template" },                       // Templates ( }} )
        { regex: /\|/, token: "custom-template" },                         // Pipes ( | )
        { regex: /\[\[(?:(?!\]\]|\|).)*\]\]/, token: "custom-link" },      // Links ( [[something]] )
        { regex: /\[\[(.*?)\|/, token: "custom-link" },                    // Links ( [[something| )
        { regex: /\]\]/, token: "custom-link" },                           // Links ( ]] )
        { regex: /\<.*?\>/, token: "custom-tag" },                         // HTML tags ( <something></something> )
    ],
    template: [
        { regex: /\b([^\|\}\n]+)/, token: "custom-template-name", next: "start" }, // Template name without {{ and |, until | or }}
        { regex: /#([^\|\}\n]+)/, token: "custom-parser-name", next: "start" },    // Parser name without {{ and |, until | or }}
        { regex: /\}\}/, token: "custom-template", next: "start" },                // Template closing ( }} )
        { regex: /\|/, token: "custom-template" },                                 // Pipes within template
    ]
});

var editor = CodeMirror.fromTextArea(document.getElementById("textareaInput"), {
    lineNumbers: true,
    lineWrapping: true,
    mode: "customMode",
    theme: "default"
});

var editor2 = CodeMirror.fromTextArea(document.getElementById("textareaInput2"), {
    lineNumbers: true,
    lineWrapping: true,
    mode: "customMode",
    theme: "default"
});

var output = CodeMirror.fromTextArea(document.getElementById("textareaOutput"), {
    readOnly: true,
    lineWrapping: true,
    mode: "",
    theme: "default"
});

var output2 = CodeMirror.fromTextArea(document.getElementById("textareaOutput2"), {
    readOnly: true,
    lineWrapping: true,
    mode: "",
    theme: "default"
});

function translatetext() {
    if (document.querySelector(".tab-btn-active").id === "mc-tmp") {
        translateuk();
    } else if (document.querySelector(".tab-btn-active").id === "mc-name") {
        translateNames();
    }
}

function translateuk() {
    const text = editor.getValue();

    let radioButtons = document.getElementsByName('templates');

    for (let i = 0; i < radioButtons.length; i++) {
        if (radioButtons[i].checked) {
            let id = radioButtons[i].id;
            console.log(id);

            if (id === 'auto') {
                console.log('yea')
                console.log(text);
                if (text.includes('{{ID table')) {
                    id_table(text);
                } else if (text.includes('{{Sound table') || text.includes('{{SoundTable')) {
                    sound_table(text);
                } else if (text.includes('{{Version nav') || text.includes('{{Infobox version') || text.includes('{{infobox version')) {
                    version_nav(text);
                } else if (text.includes('{{Entity') || text.includes('{{Infobox entity')) {
                    entity(text);
                } else if (text.includes('{{Infobox block')) {
                    block(text);
                } else if (text.includes('{{Drops')) {
                    dropsTable(text);
                } else if (text.includes('{{History')) {
                    historyTable(text);
                } else if (text.includes('{{Looming')) {
                    looming(text);
                } else if (text.includes('{{Infobox biome')) {
                    biome(text);
                } else if (text.includes('{{Spawn table') || text.includes('{{Spawn row')) {
                    spawnTable(text);
                } else if (text.includes('{{Infobox item')) {
                    item(text);
                } else if (text.includes('{{Infobox item entity') {
                    itemEntity(text);
                } else if (text === "") {
                    output.setValue("Введіть справжній текст шаблона, а не пустоту");
                } else {
                    output.setValue("Неможливо розпізнати шаблон");
                }
            } else if (id === 'id') {
                id_table(text);
            } else if (id === 'sound') {
                sound_table(text);
            } else if (id === 'vn') {
                version_nav(text);
            } else if (id === 'entity') {
                entity(text);
            } else if (id === 'block') {
                block(text);
            } else if (id === 'drops') {
                dropsTable(text);
            } else if (id === 'historyTable') {
                historyTable(text);
            } else if (id === 'looming') {
                looming(text);
            } else if (id === 'biome') {
                biome(text);
            } else if (id === 'spawnTable') {
                spawnTable(text);
            } else if (id === 'item') {
                item(text);
            } else if (id === 'itemEntity') {
                itemEntity(text);
            }
            return;
        }
    }
}

function performReplacements(text, replacementsObject) {
    for (let key in replacementsObject) {
        if (replacementsObject.hasOwnProperty(key)) {
            let regex = new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            text = text.replace(regex, replacementsObject[key]);
        }
    }
    return text;
}

function highlightAdditions(oldText, text, elClass) {
    output.setValue(text);
    let oldLines = oldText.split("\n");
    let newLines = text.split("\n");

    for (let i = 0; i < newLines.length; i++) {
        if (i >= oldLines.length) {
            // Якщо новий рядок довший ніж старий, виділити всю частину нового рядка
            let pos = output.indexFromPos({line: i, ch: 0});
            let from = output.posFromIndex(pos);
            let to = output.posFromIndex(pos + newLines[i].length);
            output.markText(from, to, {
                className: elClass === undefined ? "cm-diff-added-green" : elClass,
                inclusiveLeft: false,
                inclusiveRight: false
            });
            continue;
        }

        let oldWords = oldLines[i].split(/\s+/);
        let newWords = newLines[i].split(/\s+/);

        let pos = output.indexFromPos({line: i, ch: 0});

        for (let j = 0; j < newWords.length; j++) {
            if (j >= oldWords.length || oldWords[j] !== newWords[j]) {
                let from = output.posFromIndex(pos);
                let to = output.posFromIndex(pos + newWords[j].length);

                output.markText(from, to, {
                    className: elClass === undefined ? "cm-diff-added-green" : elClass,
                    inclusiveLeft: false,
                    inclusiveRight: false
                });
            }

            pos += newWords[j].length + 1;
        }
    }
}


function id_table(text) {
    let oldText = text;
    let edition;
    text = performReplacements(text, replacements_id);
    text = text.split("\n");
    for (let i = 1; i < text.length; i++) {
        if (text[i].includes('java') || text[i].includes('je') || text[i].includes('JE')) {
            edition = "java";
        } if (text[i].includes('bedrock') || text[i].includes('be') || text[i].includes('BE')) {
            edition = "bedrock";
        }
        
        if (text[i].includes("відображуванеім'я")) {
            console.log(edition);
            switch (edition) {
            case "bedrock":
                text[i] = translateBedrock(text[i]);
                break;
            default:
                text[i] = translateJava(text[i]);
                break;
            }
        }
    }
    text = text.join("\n");
    highlightAdditions(oldText, text);
}

function sound_table(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => segment.includes("subtitle") ? translateJava(performReplacements(segment, replacements_sound)) : performReplacements(segment, replacements_sound))
        .join("\n"));
}

function version_nav(text) {
    let oldText = text;
    text = performReplacements(text, replacements_vn);
    let lines = text.split("\n");

    for (let line of lines) {
        if (line.includes('зобр2')) {
            image2_line = line;
            let edition = null;
            m = image2_line.replace('.png', 'Тут потрібно розрізати');
            if (m.includes('Bedrock')) {
                if (m.includes('Edition')) {
                    m = m.replace("Bedrock Edition ", "Тут потрібно розрізати");
                } else {
                    m = m.replace("Bedrock ", "Тут потрібно розрізати");
                }
                edition = "Bedrock";
            } else if (m.includes('Pocket')) {
                m = m.replace("Pocket Edition ", "Тут потрібно розрізати");
                edition = "Pocket";
            } else if (m.includes('Windows 10')) {
                m = m.replace("Windows 10 Edition ", "Тут потрібно розрізати");
                edition = "Windows 10";
            } else if (m.includes('Java')) {
                m = m.replace("Java Edition ", "Тут потрібно розрізати");
                edition = "Java";
            }
            m = m.split("Тут потрібно розрізати");
            if (edition !== null) {
                let changed_image_line = m[0] + m[1] + " (" + edition + " Edition) меню.png" + m[2];
                text = text.replace(image2_line, changed_image_line)
            }
        } else if (line.includes('дата')) {
            text = text.replace(line, dateTranslation(line));
        }
    }
    highlightAdditions(oldText, text);
}

function entity(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => (segment.includes("invimage") || segment.includes("usableitems") || segment.includes("{{drop")) ? translateJava(performReplacements(segment, replacements_entity)) : performReplacements(segment, replacements_entity))
        .join("\n"));
}

function block(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => segment.includes("invimage") ? translateJava(performReplacements(segment, replacements_block)) : performReplacements(segment, replacements_block))
        .join("\n"));
}

function dropsTable(text) {
    highlightAdditions(text, text
        .split("|")
        .map(segment => segment.includes("name") ? translateJava(performReplacements(segment, replacements_drops)) : performReplacements(segment, replacements_drops))
        .join("|"));
}

function historyTable(text) {
    let oldText = text;
    text = performReplacements(text, replacements_history);
    text = text.split("|");
    for (let i = 0; i < text.length; i++) {
        for (let month in monthes) {
            if (text[i].includes(month)) {
                text[i] = dateTranslation(text[i]);
            }
        }
    }
    text = text.join("|");
    highlightAdditions(oldText, text);
}

function looming(text) {
    let oldText = text;
    const colors = {
        "White": { n: "Білий", f: "білою", m: "білим", pl: "білими" },
        "Light Gray": { n: "Світло-сірий", f: "світло-сірою", m: "світло-сірим", pl: "світло-сірими" },
        "Gray": { n: "Сірий", f: "сірою", m: "сірим", pl: "сірими" },
        "Black": { n: "Чорний", f: "чорною", m: "чорним", pl: "чорними" },
        "Brown": { n: "Коричневий", f: "коричневою", m: "коричневим", pl: "коричневими" },
        "Red": { n: "Червоний", f: "червоною", m: "червоним", pl: "червоними" },
        "Orange": { n: "Помаранчевий", f: "помаранчевою", m: "помаранчевим", pl: "помаранчевими" },
        "Yellow": { n: "Жовтий", f: "жовтою", m: "жовтим", pl: "жовтими" },
        "Lime": { n: "Лаймовий", f: "лаймовою", m: "лаймовим", pl: "лаймовими" },
        "Green": { n: "Зелений", f: "зеленою", m: "зеленим", pl: "зеленими" },
        "Cyan": { n: "Бірюзовий", f: "бірюзовою", m: "бірюзовим", pl: "бірюзовими" },
        "Light Blue": { n: "Блакитний", f: "блакитною", m: "блакитним", pl: "блакитними" },
        "Blue": { n: "Синій", f: "синьою", m: "синім", pl: "синіми" },
        "Purple": { n: "Фіолетовий", f: "фіолетовою", m: "фіолетовим", pl: "фіолетовими" },
        "Magenta": { n: "Пурпуровий", f: "пурпуровою", m: "пурпуровим", pl: "пурпуровими" },
        "Pink": { n: "Рожевий", f: "рожевою", m: "рожевим", pl: "рожевими" }
    };
    const bannerPatterns = {
        "Pale Dexter": { n: "Вертикальна смуга зліва", r: "вертикальною смугою зліва", vid: "f" },
        "Pale Sinister": { n: "Вертикальна смуга справа", r: "вертикальною смугою справа", vid: "f" },
        "Fess": { n: "Пояс", r: "поясом", vid: "m" },
        "Paly": { n: "Вертикальні смуги", r: "вертикальними смугами", vid: "pl" },
        "Saltire": { n: "Косий хрест", r: "косим хрестом", vid: "m" },
        "Cross": { n: "Хрест", r: "хрестом", vid: "m" },
        "Per Bend Sinister": { n: "Верхня ліва половина", r: "верхньою лівою половиною", vid: "f" },
        "Per Bend Inverted": { n: "Нижня ліва половина", r: "нижньою лівою половиною", vid: "f" },
        "Per Bend Sinister Inverted": { n: "Нижня права половина", r: "нижньою правою половиною", vid: "f" },
        "Bend Sinister": { n: "Діагональ справа наліво", r: "діагоналлю справа наліво", vid: "f" },
        "Per Bend": { n: "Верхня права половина", r: "верхньою правою половиною", vid: "f" },
        "Per Pale Inverted": { n: "Права половина", r: "правою половиною", vid: "f" },
        "Per Pale": { n: "Ліва половина", r: "лівою половиною", vid: "f" },
        "Per Fess Inverted": { n: "Нижня половина", r: "нижньою половиною", vid: "f" },
        "Per Fess": { n: "Верхня половина", r: "верхньою половиною", vid: "f" },
        "Base Dexter Canton": { n: "Криж зліва знизу", r: "крижем зліва знизу", vid: "m" },
        "Base Sinister Canton": { n: "Криж справа знизу", r: "крижем справа знизу", vid: "m" },
        "Chief Dexter Canton": { n: "Криж зліва згори", r: "крижем зліва згори", vid: "m" },
        "Chief Sinister Canton": { n: "Криж справа згори", r: "крижем зліва згори", vid: "m" },
        "Inverted Chevron": { n: "Шеврон згори", r: "шевроном згори", vid: "m" },
        "Chevron": { n: "Шеврон", r: "шевроном", vid: "m" },
        "Base Indented": { n: "Зубці знизу", r: "зубцями знизу", vid: "pl" },
        "Chief Indented": { n: "Зубці згори", r: "зубцями згори", vid: "pl" },
        "Roundel": { n: "Круг", r: "кругом", vid: "m" },
        "Lozenge": { n: "Ромб", r: "ромбом", vid: "m" },
        "Bordure Indented": { n: "Зубчата рамка", r: "зубчатою рамкою", vid: "f" },
        "Bordure": { n: "Рамка", r: "рамкою", vid: "f" },
        "Field Masoned": { n: "Цегляне тло", r: "цегляним тлом", vid: "m" },
        "Base Gradient": { n: "Градієнт знизу", r: "градієнтом знизу", vid: "m" },
        "Gradient": { n: "Градієнт згори", r: "градієнтом згори", vid: "m" },
        "Creeper Charge": { n: "Емблема кріпера", r: "емблемою кріпера", vid: "f" },
        "Skull Charge": { n: "Емблема черепа", r: "емблемою черепа", vid: "f" },
        "Flower Charge": { n: "Емблема квітки", r: "емблемою квітки", vid: "f" },
        "Thing": { n: "Річ", r: "річчю", vid: "f" },
        "Globe": { n: "Глобус", r: "глобусом", vid: "m" },
        "Snout": { n: "Рило", r: "рилом", vid: "m" },
        "Flow": { n: "Плин", r: "плином", vid: "m" },
        "Guster": { n: "Порив", r: "поривом", vid: "m" },
        "Base": { n: "Основа", r: "основою", vid: "f" },
        "Bend": { n: "Діагональ зліва направо", r: "діагоналлю зліва направо", vid: "f" },
        "Pale": { n: "Стовп", r: "стовпом", vid: "m" },
        "Chief": { n: "Верх", r: "верхом", vid: "m" }
    };

    const regex = /(?:^|\[|=|\|)([^\|\]\[=\n]*?Banner[^\|\]\[=\n]*?)(?=\||\]|\n|$)/g;

    const matches = [];
    let match;
    while ((match = regex.exec(text)) !== null) {
        matches.push(match[1]);
    }

    for (let match of matches) {
        let usedColor;
        let usedPattern;
        let vidm;

        for (let color in colors) {
            if (match.includes(color)) {
                usedColor = color;
                break;
            }
        }

        for (let pattern in bannerPatterns) {
            if (match.includes(pattern)) {
                usedPattern = pattern;
                vidm = bannerPatterns[pattern].vid;
                break;
            }
        }

        if (usedPattern !== undefined)  {
            if (usedColor !== undefined) {
                if (match.includes("Dyed")) {
                    text = text.replace(match, `Пофарбований стяг з ${colors[usedColor][vidm]} ${bannerPatterns[usedPattern].r}`);
                } else {
                    text = text.replace(match, `Стяг з ${colors[usedColor][vidm]} ${bannerPatterns[usedPattern].r}`);
                }
            } else if (match.includes("Dyed")) {
                text = text.replace(match, `Пофарбований стяг з ${bannerPatterns[usedPattern].r}`);
            } else if (match.includes("Banner Pattern")) {
                text = text.replace(match, `Візерунок стяга «${bannerPatterns[usedPattern].n}»`);
            } else {
                text = text.replace(match, `Стяг з ${bannerPatterns[usedPattern].r}`);
            }
        } else if (usedColor !== undefined) {
            text = text.replace(match, `${colors[usedColor].n} стяг`);
        }
    }

    for (let pattern in bannerPatterns) {
        if (text.includes(pattern)) {
            text = text.replace(pattern, bannerPatterns[pattern].n);
        }
    }

    text = text.split("\n");

    for (let line of text) {
        if (line.includes("Banner")) {
            line = line.replace("Banner", "Стяг");
        }
    }

    text = text.join("\n");

    highlightAdditions(oldText, translateJava(performReplacements(text, replacements_looming)));
}

function biome(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => (segment.includes("blocks") || segment.includes("title")) ? translateJava(performReplacements(segment, replacements_biome)) : performReplacements(segment, replacements_biome))
        .join("\n"));
}

function spawnTable(text) {
    let oldText = text;
    let edition;
    text = performReplacements(text, replacements_spawn);
    text = text.split("\n");
    for (let i = 1; i < text.length; i++) {
        if (text[i].includes('java') || text[i].includes('je') || text[i].includes('JE')) {
            edition = "java";
        } else if (text[i].includes('bedrock') || text[i].includes('be') || text[i].includes('BE')) {
            edition = "bedrock";
        }
        
        if (text[i].includes("Ряд появи")) {
            console.log(edition);
            switch (edition) {
            case "bedrock":
                text[i] = translateBedrock(text[i]);
                break;
            default:
                text[i] = translateJava(text[i]);
                break;
            }
        }
    }
    text = text.join("\n");
    highlightAdditions(oldText, text);
}

function item(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => (segment.includes("invimage")) || segment.includes("title") ? translateJava(performReplacements(segment, replacements_item)) : performReplacements(segment, replacements_item))
        .join("\n"));
}

function itemEntity(text) {
    highlightAdditions(text, text
        .split("\n")
        .map(segment => (segment.includes("invimage")) || segment.includes("title") ? translateJava(performReplacements(segment, replacements_itemEntity)) : performReplacements(segment, replacements_itemEntity))
        .join("\n"));
}

function dateTranslation(date) {
    let lines1;
    let date_line_new = date;
    let date_line_after = "";
    if (date.includes("<")) {
        lines1 = date.split("<");
        date_line_new = lines1[0];
        date_line_after = '<' + lines1.slice(1).join('<');
    } if (date.includes("{{")) {
        lines1 = date.split("{{");
        date_line_new = lines1[0];
        date_line_after = '{{' + lines1.slice(1).join('{{');
    } if (date.includes("}}")) {
        lines1 = date.split("}}");
        date_line_new = lines1[0];
        date_line_after = '}}' + lines1.slice(1).join('}}');
    }
    for (let [engMonth, ukrMonth] of Object.entries(monthes)) {
        if (date_line_new.includes(`${engMonth} `) && date_line_new.includes(',')) {
            let d = date_line_new.replace(',', 'Розрізати'); 
            d = d.replace(`${engMonth} `, 'Розрізати');
            d = d.split('Розрізати');
            let changed_date_line = d[0] + d[1] + ' ' + ukrMonth + d[2] + ' року' + date_line_after;

            let regexDate = new RegExp('.*\\d{1,2}.+\\d{4} року', 'g');

            if (regexDate.test(changed_date_line)) {
                console.log(`success: ${date}`);
                return changed_date_line;
            } else {
                console.log(`unsuccess: ${date}`);
                return date;
            }
        }
    }

    return date;
}

function copy(num) {
    // Створення тимчасового textarea
    let textarea = document.createElement('textarea');
    textarea.value = num === 1 ? output.getValue() : output2.getValue();
    document.body.appendChild(textarea);
    
    // Вибір тексту
    textarea.select();
    textarea.setSelectionRange(0, textarea.value.length); // Для мобільних пристроїв
    
    // Копіювання тексту
    document.execCommand('copy');
    
    // Видалення textarea
    document.body.removeChild(textarea);

    alert("Текст скопійовано!");
}

function copyText(text) {
    navigator.clipboard.writeText(text) // Копіюємо текст у буфер обміну
        .then(() => {
            alert("Текст скопійовано!");
        })
        .catch(err => {
            alert("Помилка при копіюванні тексту: ", err);
        });
}

document.getElementById('regex-search').addEventListener('change', function() {
    if (this.checked) {
        document.getElementById('regex-slash').classList.remove('hidden');
        document.getElementById('regex-slash2').classList.remove('hidden');
        if (document.getElementById('cs-search').checked) {
            document.getElementById('regex-slash2').textContent = "/g";
        } else {
            document.getElementById('regex-slash2').textContent = "/gi";
        }
    } else {
        document.getElementById('regex-slash').classList.add('hidden');
        document.getElementById('regex-slash2').classList.add('hidden');
    }
});

document.getElementById('cs-search').addEventListener('change', function() {
    if (document.getElementById('regex-search').checked) {
        if (this.checked) {
            document.getElementById('regex-slash2').textContent = "/g";
        } else {
            document.getElementById('regex-slash2').textContent = "/gi";
        }
    }
});

function toggleMenu() {
    const menu = document.getElementById('settingsMenu');
    const overlay = document.getElementById('overlay');
    if (menu.style.display === 'none' || menu.style.display === '') {
        menu.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        menu.style.display = 'none';
        overlay.style.display = 'none';
    }
}

function clearTextareas(num) {
    num === 1
        ? (editor.setValue(''), output.setValue(''))
        : (editor2.setValue(''), output2.setValue(''));
}

document.addEventListener('DOMContentLoaded', (event) => {
    if (localStorage.getItem('cookieConsent')) {
        document.getElementById('cookies-checkbox').checked = true;
        // Завантаження збережених налаштувань
        const savedBgColor = localStorage.getItem('bgColor');
        const savedTextColor = localStorage.getItem('textColor');
        const savedBtnHvBgColor = localStorage.getItem('btnHvBgColor');
        const savedBtnHvTextColor = localStorage.getItem('btnHvTextColor');
        const savedLinkColor = localStorage.getItem('linkColor');
        const savedLinkHvColor = localStorage.getItem('linkHvColor');
        const savedTAColor = localStorage.getItem('TATheme');

        if (savedBgColor) {
            document.documentElement.style.setProperty('--bg-color', savedBgColor);
            document.getElementById('bg-color').value = savedBgColor;
        }

        if (savedTextColor) {
            document.documentElement.style.setProperty('--alt-color', savedTextColor);
            document.getElementById('text-color').value = savedTextColor;
        }

        if (savedBtnHvBgColor) {
            document.documentElement.style.setProperty('--btn-hover-bg-color', savedBtnHvBgColor);
            document.getElementById('btn-hover-bg-color').value = savedBtnHvBgColor;
        }

        if (savedBtnHvTextColor) {
            document.documentElement.style.setProperty('--btn-hover-text-color', savedBtnHvTextColor);
            document.getElementById('btn-hover-text-color').value = savedBtnHvTextColor;
        }

        if (savedLinkColor) {
            document.documentElement.style.setProperty('--link-color', savedLinkColor);
            document.getElementById('link-color').value = savedLinkColor;
        }

        if (savedLinkHvColor) {
            document.documentElement.style.setProperty('--link-hover-color', savedLinkHvColor);
            document.getElementById('link-hover-color').value = savedLinkHvColor;
        }

        if (savedTAColor) {
            editor.setOption('theme', savedTAColor);
            editor2.setOption('theme', savedTAColor);
            output.setOption('theme', savedTAColor);
            output2.setOption('theme', savedTAColor);
        }
    } else {
        document.getElementById('cookies-checkbox').checked = false;
    }
});

function presetChoice(
    bgColor=document.getElementById('bg-color').value,
    textColor=document.getElementById('text-color').value,
    btnHvBgColor=document.getElementById('btn-hover-bg-color').value,
    btnHvTextColor=document.getElementById('btn-hover-text-color').value,
    linkColor=document.getElementById('link-color').value,
    linkHvColor=document.getElementById('link-hover-color').value) {
    document.getElementById('bg-color').value = bgColor;
    document.getElementById('text-color').value = textColor;
    document.getElementById('btn-hover-bg-color').value = btnHvBgColor;
    document.getElementById('btn-hover-text-color').value = btnHvTextColor;
    document.getElementById('link-color').value = linkColor;
    document.getElementById('link-hover-color').value = linkHvColor;
    document.documentElement.style.setProperty('--bg-color', bgColor);
    document.documentElement.style.setProperty('--alt-color', textColor);
    document.documentElement.style.setProperty('--btn-hover-bg-color', btnHvBgColor);
    document.documentElement.style.setProperty('--btn-hover-text-color', btnHvTextColor);
    document.documentElement.style.setProperty('--link-color', linkColor);
    document.documentElement.style.setProperty('--link-hover-color', linkHvColor);
    if (localStorage.getItem('cookieConsent')) {
        localStorage.setItem('bgColor', bgColor);
        localStorage.setItem('textColor', textColor);
        localStorage.setItem('btnHvBgColor', btnHvBgColor);
        localStorage.setItem('btnHvTextColor', btnHvTextColor);
        localStorage.setItem('linkColor', linkColor);
        localStorage.setItem('linkHvColor', linkHvColor);
    }
}

function setTheme(theme) {
    editor.setOption('theme', theme);
    editor2.setOption('theme', theme);
    output.setOption('theme', theme);
    output2.setOption('theme', theme);
    if (localStorage.getItem('cookieConsent')) {
        localStorage.setItem('TATheme', theme);
    }
}


document.getElementById("cookies-checkbox").addEventListener('change', function() {
    if (this.checked) {
        localStorage.setItem('cookieConsent', 'true');
        presetChoice();
    } else {
        localStorage.clear();
    }
});


// Подія для кнопки "Погоджуюсь"
document.getElementById('agree-btn').addEventListener('click', function() {
    localStorage.setItem('cookieConsent', 'true'); // Зберігаємо згоду у localStorage
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookies-checkbox').checked = true;
    presetChoice();
});

document.getElementById('disagree-btn').addEventListener('click', function() {
    localStorage.clear();
    document.getElementById('cookie-banner').style.display = 'none';
    document.getElementById('cookies-checkbox').checked = false;
});

function openTab(tabId, btnId) {
    if (document.querySelector(".tab-btn-active").id !== btnId) {
        // Сховати всі вкладки
        var tabs = document.getElementsByClassName('tab');
        for (var i = 0; i < tabs.length; i++) {
            tabs[i].style.display = 'none';
        }
        document.getElementById(tabId).style.display = 'flex';

        // Показати активну вкладку
        var activeButton = document.getElementById(btnId);

        activeButton.style.display = 'flex';

        editor2.refresh();

        // Зняти активність з усіх кнопок та очистити їхній текст
        var buttons = document.querySelectorAll('.tab-buttons button');
        buttons.forEach(button => {
            button.classList.remove('tab-btn-active');
        });

        activeButton.classList.add('tab-btn-active');
    }
}

const url = new URL(window.location.href);
const params = new URLSearchParams(url.search);

const tabVar = params.get('tab'); // url var 1
const modeVar = params.get('mode'); // url var 2
const modesVar = params.get('modes'); // url var 3
const textVar = params.get('text'); // url var 4
const verVar = params.get('ver'); // url var 5
const ver2Var = params.get('ver2'); // url var 6
// example: https://metrokop228.github.io/UkMCW-templates-translation?tab=2&mode=java&text=Wolf
window.onload = function() {
    if (tabVar == "2") {
        document.getElementById('mc-name').click();
        if (modeVar) {
            document.getElementById(modeVar).checked = true; // Вибрати радіокнопку
        }
        if (verVar) {
            for (option in document.getElementById('version-choice-java').options) {
                if (document.getElementById('version-choice-java').options[option].value === verVar && document.getElementById('version-choice-java').options[option].disabled === false) {
                    document.getElementById('version-choice-java').value = verVar;
                }
            }
            for (option in document.getElementById('version-choice-bedrock').options) {
                if (document.getElementById('version-choice-bedrock').options[option].value === verVar && document.getElementById('version-choice-bedrock').options[option].disabled === false) {
                    document.getElementById('version-choice-bedrock').value = verVar;
                }
            }
            syncVers();
        }
        if (textVar) {
            editor2.setValue(textVar);
            timeoutForTr2();
        }
    } else if (tabVar == "3") {
        document.getElementById('mc-name-search').click();
        if (modeVar) {
            for (let i = 0; i < document.getElementsByName('editions2').length; i++) {
                if (document.getElementsByName('editions2')[i].id == modeVar) {
                    document.getElementsByName('editions2')[i].checked = true; // Вибрати радіокнопку
                }
            }
        }
        if (verVar) {
            for (option in document.getElementById('version-choice-java2').options) {
                if (document.getElementById('version-choice-java2').options[option].value === verVar && document.getElementById('version-choice-java2').options[option].disabled === false) {
                    document.getElementById('version-choice-java2').value = verVar;
                }
            }
            for (option in document.getElementById('version-choice-bedrock2').options) {
                if (document.getElementById('version-choice-bedrock2').options[option].value === verVar && document.getElementById('version-choice-bedrock2').options[option].disabled === false) {
                    document.getElementById('version-choice-bedrock2').value = verVar;
                }
            }
            syncVers();
        }
        if (modesVar) {
            if (modesVar.includes("g")) {
                document.getElementById("global-search").click();
            } if (modesVar.includes("r")) {
                document.getElementById("regex-search").click();
            } if (modesVar.includes("i")) {
                document.getElementById("cs-search").click();
            }
        }
        if (textVar) {
            document.getElementById("text-to-search").value = textVar;
            timeoutForSearch();
        }
    } else if (tabVar == "4") {
        document.getElementById('mc-name-compare').click();
        if (modeVar) {
            for (option in document.getElementById('edition-choice-changes').options) {
                if (document.getElementById('edition-choice-changes').options[option].value === modeVar && document.getElementById('edition-choice-changes').options[option].disabled === false) {
                    document.getElementById('edition-choice-changes').value = modeVar;
                    syncCompareOptions();
                }
            }
        }
        if (verVar) {
            for (option in document.getElementById('compare-version-1').options) {
                if (document.getElementById('compare-version-1').options[option].value === verVar && document.getElementById('compare-version-1').options[option].disabled === false) {
                    document.getElementById('compare-version-1').value = verVar;

                    if (ver2Var > verVar) {
                        for (option in document.getElementById('compare-version-2').options) {
                            if (document.getElementById('compare-version-2').options[option].value === ver2Var && document.getElementById('compare-version-2').options[option].disabled === false) {
                                document.getElementById('compare-version-2').value = ver2Var;
                            }
                        }
                    }
                }
            }
        }
        timeoutForComparison();
    } else {
        if (modeVar) {
            document.getElementById(modeVar).checked = true; // Вибрати радіокнопку
        }
        if (textVar) {
            editor.setValue(textVar);
            setTimeout(() => {
                document.getElementById('button-tr1').click();
            }, 200);
        }
    }
    console.log(`Tab: ${tabVar}, Mode: ${modeVar}, Text: ${textVar}, Modes: ${modesVar}, Ver: ${verVar}, Ver2: ${ver2Var}`)

    if (!localStorage.getItem('cookieConsent')) {
        document.getElementById('cookie-banner').style.display = 'flex';
    }
}

function timeoutForTr2() {
    if (translations_java['1.13'] !== undefined && translations_bedrock['1.21.0'] !== undefined && translations_earth !== undefined && translations_legends !== undefined && translations_education !== undefined) {
        document.getElementById('button-tr2').click();
    } else {
        setTimeout(() => {
            timeoutForTr2();
        }, 200);
    }
}
function timeoutForSearch() {
    if (translations_java['1.13'] !== undefined && translations_bedrock['1.21.0'] !== undefined && translations_earth !== undefined && translations_legends !== undefined && translations_education !== undefined) {
        searchMatches();
    } else {
        setTimeout(() => {
            timeoutForSearch();
        }, 200);
    }
}
function timeoutForComparison() {
    if (translations_java['1.13'] !== undefined && translations_bedrock['1.21.0'] !== undefined && translations_earth !== undefined && translations_legends !== undefined && translations_education !== undefined) {
        trackChanges();
    } else {
        setTimeout(() => {
            timeoutForComparison();
        }, 200);
    }
}

function getLink(tab) {
    let link = "https://metrokop228.github.io/UkMCW-templates-translation";
    const getCheckedId = (name) => {
        const elements = document.getElementsByName(name);
        for (let element of elements) {
            if (element.checked) return element.id;
        }
    };

    if (tab === 2) {
        link += `?tab=${tab}`;
        const mode = getCheckedId("editions") || "java";
        if (mode !== "java") {
            link += `&mode=${encodeURIComponent(mode)}`;
            if (document.getElementById("version-choice-bedrock").value !== newestBeVer) link += `&ver=${encodeURIComponent(document.getElementById("version-choice-bedrock").value)}`;
        } else {
            if (document.getElementById("version-choice-java").value !== newestJeVer) link += `&ver=${encodeURIComponent(document.getElementById("version-choice-java").value)}`;
        }
        if (editor2.getValue()) link += `&text=${encodeURIComponent(editor2.getValue())}`;
    } else if (tab === 3) {
        const mode = getCheckedId("editions2") || "java";
        link += `?tab=${tab}`;
        if (mode !== "java") {
            link += `&mode=${encodeURIComponent(mode)}`;
            if (document.getElementById("version-choice-bedrock2").value !== newestBeVer) link += `&ver=${encodeURIComponent(document.getElementById("version-choice-bedrock2").value)}`;
        } else {
            if (document.getElementById("version-choice-java2").value !== newestJeVer) link += `&ver=${encodeURIComponent(document.getElementById("version-choice-java2").value)}`;
        }
        let modes = "";
        if (!document.getElementById("global-search").checked) modes += 'g';
        if (document.getElementById("regex-search").checked) modes += 'r';
        if (!document.getElementById("cs-search").checked) modes += 'i';
        if (modes) link += `&modes=${modes}`;
        if (document.getElementById("text-to-search").value) link += `&text=${encodeURIComponent(document.getElementById("text-to-search").value)}`;
    } else {
        const mode = getCheckedId("templates") || "auto";
        if (mode !== "auto") {
            link += `?mode=${encodeURIComponent(mode)}`;
            if (editor.getValue()) link += `&text=${encodeURIComponent(editor.getValue())}`;
        } else if (editor.getValue()) {
            link += `?text=${encodeURIComponent(editor.getValue())}`;
        }
    }

    console.log("Link: " + link);

    // Копіювання посилання в буфер обміну
    navigator.clipboard.writeText(link).then(() => {
        console.log("Link copied to clipboard!");
        alert("Посилання скопійовано :)");
    }).catch(err => {
        console.error("Could not copy link: ", err);
    });
}

